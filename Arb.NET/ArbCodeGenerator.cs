#if !ARB_GENERATOR
using System.IO;
#endif
using System.Text;
using System.Text.RegularExpressions;

namespace Arb.NET;

/// <summary>
/// Generates C# code from parsed .arb documents
/// </summary>
public class ArbCodeGenerator {
    // Matches ARB placeholder tokens like {username} or {count}
    private static readonly Regex PlaceholderPattern = new(@"\{(\w+)\}", RegexOptions.Compiled);

    /// <summary>
    /// Generates a C# class from an ARB document
    /// </summary>
    public string GenerateClass(ArbDocument document, string className, string namespaceName) {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"// Locale: {document.Locale}");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public partial class {className} {{");

        foreach (var entry in document.Entries.Values) {
            GenerateEntry(sb, entry);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

#if !ARB_GENERATOR
    /// <summary>
    /// Parses an .arb file and writes a generated C# file to <paramref name="outputPath"/>
    /// </summary>
    public void GenerateClassFile(string arbFilePath, string outputPath, string className, string namespaceName) {
        var result = new ArbParser().Parse(arbFilePath);
        if (!result.ValidationResults.IsValid) {
            // TODO
            return;
        }
        var source = GenerateClass(result.Document!, className, namespaceName);
        Directory.CreateDirectory(Path.GetDirectoryName(outputPath) ?? ".");
        File.WriteAllText(outputPath, source);
    }
#endif
    
    private static void GenerateEntry(StringBuilder sb, ArbEntry entry) {
        var placeholders = entry.Metadata?.Placeholders;

        if (placeholders is { Count: > 0 }) {
            // Build parameter list: ordered by their appearance in the value string
            var paramNames = OrderedPlaceholderNames(entry.Value, placeholders);
            var paramList = BuildParamList(paramNames, placeholders);

            // Replace {name} tokens with {0}, {1}, ... positional args
            var formatString = BuildFormatString(entry.Value, paramNames);

            sb.AppendLine();
            sb.AppendLine($"    /// <summary>{entry.Metadata?.Description ?? entry.Key}</summary>");
            sb.AppendLine($"    public string {StringHelper.ToPascalCase(entry.Key)}({paramList})");
            sb.AppendLine($"        => string.Format(\"{StringHelper.EscapeString(formatString)}\", {string.Join(", ", paramNames)});");
        }
        else {
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>{entry.Metadata?.Description ?? entry.Key}</summary>");
            sb.AppendLine($"    public string {StringHelper.ToPascalCase(entry.Key)} => \"{StringHelper.EscapeString(entry.Value)}\";");
        }
    }

    // Returns placeholder names ordered by first occurrence in the value string,
    // falling back to dictionary order for any not found in the string.
    private static List<string> OrderedPlaceholderNames(string value, Dictionary<string, ArbPlaceholder> placeholders) {
        var seen = new HashSet<string>();
        var ordered = new List<string>();
        foreach (Match m in PlaceholderPattern.Matches(value)) {
            var name = m.Groups[1].Value;
            if (placeholders.ContainsKey(name) && seen.Add(name))
                ordered.Add(name);
        }

        // Add any placeholders declared in metadata but not found in the string
        foreach (var key in placeholders.Keys)
            if (seen.Add(key))
                ordered.Add(key);
        return ordered;
    }

    private static string BuildParamList(List<string> names, Dictionary<string, ArbPlaceholder> placeholders) {
        var parts = new List<string>();
        foreach (var name in names) {
            var dotNetType = MapType(placeholders.TryGetValue(name, out var ph) ? ph.Type : string.Empty);
            parts.Add($"{dotNetType} {name}");
        }
        return string.Join(", ", parts);
    }

    private static string BuildFormatString(string value, List<string> orderedNames) {
        var indexMap = new Dictionary<string, int>();
        for (var i = 0; i < orderedNames.Count; i++)
            indexMap[orderedNames[i]] = i;

        return PlaceholderPattern.Replace(value, m => {
            var name = m.Groups[1].Value;
            return indexMap.TryGetValue(name, out var idx) ? $"{{{idx}}}" : m.Value;
        });
    }

    private static string MapType(string arbType) => arbType.ToLowerInvariant() switch {
        "int" or "integer" or "num" or "number" => "int",
        "double" or "float"                     => "double",
        _                                       => "string"
    };
}